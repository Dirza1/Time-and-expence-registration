// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: finances.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addTransaction = `-- name: AddTransaction :one
INSERT INTO finances (id, timestamp,date_transaction, ammount_cent, type, description, catagory)
VALUES(
    gen_random_UUID(),
    NOW(),
    $1,
    $2,
    $3,
    $4,
    $5
)
RETURNING id, timestamp, date_transaction, ammount_cent, type, description, catagory
`

type AddTransactionParams struct {
	DateTransaction time.Time
	AmmountCent     int32
	Type            string
	Description     string
	Catagory        string
}

func (q *Queries) AddTransaction(ctx context.Context, arg AddTransactionParams) (Finance, error) {
	row := q.db.QueryRowContext(ctx, addTransaction,
		arg.DateTransaction,
		arg.AmmountCent,
		arg.Type,
		arg.Description,
		arg.Catagory,
	)
	var i Finance
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.DateTransaction,
		&i.AmmountCent,
		&i.Type,
		&i.Description,
		&i.Catagory,
	)
	return i, err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
DELETE FROM finances
WHERE id = $1
`

func (q *Queries) DeleteTransaction(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTransaction, id)
	return err
}

const overviewAllTransactions = `-- name: OverviewAllTransactions :many
SELECT 
    id,
    timestamp AS "Registration Time",
    date_transaction AS "Date Transaction",
    (ammount_cent /100.0)::FLOAT8 AS "Amount",
    type,
    description,
    catagory
 FROM finances
`

type OverviewAllTransactionsRow struct {
	ID               uuid.UUID
	RegistrationTime time.Time
	DateTransaction  time.Time
	Amount           float64
	Type             string
	Description      string
	Catagory         string
}

func (q *Queries) OverviewAllTransactions(ctx context.Context) ([]OverviewAllTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, overviewAllTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OverviewAllTransactionsRow
	for rows.Next() {
		var i OverviewAllTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.RegistrationTime,
			&i.DateTransaction,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.Catagory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const overviewTransactionByCatagory = `-- name: OverviewTransactionByCatagory :many
SELECT 
    id,
    timestamp AS "Registration Time",
    date_transaction AS "Date Transaction",
    (ammount_cent /100.0)::FLOAT8 AS "Amount",
    type,
    description,
    catagory
FROM finances
WHERE catagory LIKE $1
`

type OverviewTransactionByCatagoryRow struct {
	ID               uuid.UUID
	RegistrationTime time.Time
	DateTransaction  time.Time
	Amount           float64
	Type             string
	Description      string
	Catagory         string
}

func (q *Queries) OverviewTransactionByCatagory(ctx context.Context, catagory string) ([]OverviewTransactionByCatagoryRow, error) {
	rows, err := q.db.QueryContext(ctx, overviewTransactionByCatagory, catagory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OverviewTransactionByCatagoryRow
	for rows.Next() {
		var i OverviewTransactionByCatagoryRow
		if err := rows.Scan(
			&i.ID,
			&i.RegistrationTime,
			&i.DateTransaction,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.Catagory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const overviewTransactionsDate = `-- name: OverviewTransactionsDate :many
SELECT 
    id,
    timestamp AS "Registration Time",
    date_transaction AS "Date Transaction",
    (ammount_cent /100.0)::FLOAT8 AS "Amount",
    type,
    description,
    catagory
FROM finances
WHERE date_transaction >= $1 AND date_transaction <= $2
`

type OverviewTransactionsDateParams struct {
	DateTransaction   time.Time
	DateTransaction_2 time.Time
}

type OverviewTransactionsDateRow struct {
	ID               uuid.UUID
	RegistrationTime time.Time
	DateTransaction  time.Time
	Amount           float64
	Type             string
	Description      string
	Catagory         string
}

func (q *Queries) OverviewTransactionsDate(ctx context.Context, arg OverviewTransactionsDateParams) ([]OverviewTransactionsDateRow, error) {
	rows, err := q.db.QueryContext(ctx, overviewTransactionsDate, arg.DateTransaction, arg.DateTransaction_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OverviewTransactionsDateRow
	for rows.Next() {
		var i OverviewTransactionsDateRow
		if err := rows.Scan(
			&i.ID,
			&i.RegistrationTime,
			&i.DateTransaction,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.Catagory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetTransaction = `-- name: ResetTransaction :exec
DELETE from finances
`

func (q *Queries) ResetTransaction(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetTransaction)
	return err
}

const totalTransactionsDates = `-- name: TotalTransactionsDates :one
SELECT sum(ammount_cent/100.0)::FLOAT8
FROM finances
WHERE date_transaction >= $1 AND date_transaction <= $2
`

type TotalTransactionsDatesParams struct {
	DateTransaction   time.Time
	DateTransaction_2 time.Time
}

func (q *Queries) TotalTransactionsDates(ctx context.Context, arg TotalTransactionsDatesParams) (float64, error) {
	row := q.db.QueryRowContext(ctx, totalTransactionsDates, arg.DateTransaction, arg.DateTransaction_2)
	var column_1 float64
	err := row.Scan(&column_1)
	return column_1, err
}

const updateTransaction = `-- name: UpdateTransaction :one
UPDATE finances
SET date_transaction = $1, ammount_cent = $2, type = $3, description = $4, catagory = $5
WHERE id = $6
RETURNING id, timestamp, date_transaction, ammount_cent, type, description, catagory
`

type UpdateTransactionParams struct {
	DateTransaction time.Time
	AmmountCent     int32
	Type            string
	Description     string
	Catagory        string
	ID              uuid.UUID
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (Finance, error) {
	row := q.db.QueryRowContext(ctx, updateTransaction,
		arg.DateTransaction,
		arg.AmmountCent,
		arg.Type,
		arg.Description,
		arg.Catagory,
		arg.ID,
	)
	var i Finance
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.DateTransaction,
		&i.AmmountCent,
		&i.Type,
		&i.Description,
		&i.Catagory,
	)
	return i, err
}
